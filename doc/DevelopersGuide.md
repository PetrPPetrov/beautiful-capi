Beautiful-Capi Developer's Guide
================================

1. [Introduction](#introduction)
    * [C++ problems](#c-problems)
        * [C++ ABI](#c-abi)
        * [Name mangling](#name-mangling)
        * [C++ STL ABI](#c-stl-abi)
        * [Exceptions](#exceptions)
    * [Basic solutions](#basic-solutions)
    * [Beautiful Capi solution](#beautiful-capi-solution)
2. [Lifecycle semantics](#lifecycle-semantics)
    * [Copy semantic](#copy-semantic)
    * [Reference counted semantic](#reference-counted-semantic)
    * [Raw pointer semantic](#raw-pointer-semantic)
    * [Common methods of the wrapper classes](#common-methods-of-the-wrapper-classes)
3. [Classification of types](#classification-of-types)
    * [Classes](#classes)
    * [Mapped types](#mapped-types)
    * [Enumeration types](#enumeration-types)
    * [External classes](#external-classes)
    * [Built-in types](#built-in-types)
4. [Mixing semantics](#mixing-semantics)
    * [Casting attributes](#casting-attributes)
    * [Lifecycle extensions](#lifecycle-extensions)
5. [Exception handling](#exception-handling)
6. [Callbacks](#callbacks)
7. [Dynamic casts](#dynamic-casts)
8. [Templates](#templates)
9. [Snippets](#snippets)
10. [Inheritance modes](#inheritance-modes)
11. [Properties](#properties)
12. [Unit tests](#unit-tests)
13. [Implementation code](#implementation-code)
14. [Cascading libraries](#cascading-libraries)
15. [Secured API](#secured-api)
16. [Making compiler-independent libraries](#making-compiler-independent-libraries)
    * [Dynamic loader](#dynamic-loader)
    * [Windows](#windows)
    * [Linux](#linux)
    * [MacOSX](#macosx)
17. [Command-line arguments](#command-line-arguments)
18. [Integration with CMake](#integration-with-cmake)
19. [XML API description schema reference](#xml-api-description-schema)
20. [XML generation parameters schema](#xml-generation-parameters-schema)    

Introduction
------------

Beautiful Capi is a tool which automates the creation of compiler-independent
and binary compatible C++ libraries across different C++ compilers.
Libraries prepared by Beautiful Capi enable C++ libraries to be compiled once then used many times
by the other C++ compilers without any recompilation.
Of course, the compiled C++ libraries are compatible only on the same platforms
and architectures where they were built. For instance, a shared library which was built by Visual Studio 2015
C++ compiler could be wrapped and called by Mingw Clang C++ compiler on Windows operating system
(allowing both forward and backward compatibility) and vice versa.

This tool generates the required C++ and C code to wrap your C++ classes for use in a compiler-independent way.

Another main concept is to generate a well-crafted beautiful C API,
which is clear, readable and visibly suitable for human usage (not only for computers or compilers).

Beautiful Capi is written in Python 3. Note it _does not parse_ the library source code to obtain its
[API](https://en.wikipedia.org/wiki/Application_programming_interface) description.
Instead of that, as author you should provide a library API description in XML format.
Usually such XML files which describe the library API are created by hand.
There are no tools for creating XML API description files yet, however, such tools could be created in the future.
There are [plans](https://github.com/PetrPPetrov/beautiful-capi/issues/24)
to add support of some convenient DSL (Domain-Specific Language) in parallel to XML format. 

Beautiful Capi is not intended as a tool for automating cross-language C++ library creation (for instance,
the cases when a C++ library is used in Java or C# application) like [SWIG](http://www.swig.org/).
However, in the future Beautiful Capi could introduce such features and support for some other target languages.
For details please see [issue 7](https://github.com/PetrPPetrov/beautiful-capi/issues/7) and
[issue 39](https://github.com/PetrPPetrov/beautiful-capi/issues/39).

The main goal of this project is to produce highly efficient code and design elegance.
This goal is informed by knowing Java programmers prefer to write wrappers by hand to avoid sub-optimal SWIG outputs.

Beautiful Capi has many examples which help to learn it step by step.
You can find all examples in [examples](https://github.com/PetrPPetrov/beautiful-capi/tree/master/examples) folder.

Regarding the license - the code generated by this tool can be used for any purpose, including commercial.
Only the code generator tool itself is subject to GPL licensing.

### C++ problems

#### C++ ABI

The one of the well-known C++ language problems is [ABI](https://en.wikipedia.org/wiki/Application_binary_interface)
(Application Binary Interface) incompatibility.
The C++ language standard does not specify any ABI and it is implementation specific.
For instance, the C++ language standard does not define size of _int_ type.
Each C++ compiler vendor can provide his own implementation of ABI.
Any C++ library must be built again and again for every different C++ compiler which needs
to use the library in an application.

#### Name mangling

The second problem in C++ is [name mangling](https://en.wikipedia.org/wiki/Name_mangling).
In C++ name mangling is an encoding scheme which translates
complex C++ identifiers (including overloaded functions and methods, template instantiations,
namespaces, etc.) to plain C functions. The C++ language standard does not specify any name mangling scheme.
Again, each C++ compiler vendor can provide his own implementation of name manging.
A C++ compiler is used to build an application could use a different name mangling scheme
incompatible from the C++ compiler used for building the original library.
The typical result for the developer of the application is to face unresolved symbol linking errors.

#### C++ STL ABI

The third problem is binary incompatible C++ _standard_ libraries.
For instance, the size of _std::string_ class is implementation specific and could vary
from one C++ compiler to another, and even from one build configuration to another.

#### Exceptions

Different C++ compilers implement different exception throwing and catching schemas.
An exception thrown from one C++ compiler runtime, in general,
could not be caught and managed by another C++ compiler runtime.

### Basic solutions

C++ application developers face and work-around these issues every day with some basic coding methods.
A common basic solution for providing a stable ABI is to use special types which have fixed sizes.
For instance, using _int32_t_ type instead of _int_ type, etc.
The calling convention is also important, so, the developer needs to manually specify the calling
convention for each method or function in the library.

The basic solution for overcoming different name mangling schemes is to manually write plain C functions.
However, it is boiler-plate and error-prone, reducing development productivity.

The basic solution for the binary incompatible C++ standard libraries problem is to avoid
exposing C++ standard library classes at the library public API.
So, the library API should contain only primitive
and fixed sized types in its API. As result, a developer should manually split some
complex C++ standard library templates (such as _std::vector<>_, _std::map<>_) to primitive functions and types,
which is also boiler-plate and error-prone.

Also, the developer is often forced to manually write C++ wrapper classes which will expose
some higher level API rather than plain C functions and types.
Such a process is laborious, boiler-plate and error-prone.

### Beautiful Capi solution

Beautiful Capi is a tool which automates the creation of compiler-independent C++ libraries.
It greatly helps to solve the name mangling problem, generating C++ wrapper classes,
wrapping C++ STL library template classes, catching and rethrowing exceptions and much more.

Consider [hello_world](https://github.com/PetrPPetrov/beautiful-capi/tree/master/examples/hello_world)
Beautiful Capi example. It exposes the following class:
~~~C++
#include <iostream>

namespace HelloWorld
{
    class PrinterImpl
    {
    public:
        void Show() const;
    };
}

void HelloWorld::PrinterImpl::Show() const
{
    std::cout << "Hello Beautiful World!" << std::endl;
}
~~~

In fact _HelloWorld::PrinterImpl_ class is an internal class and it is not exposed directly
for _HelloWorld_ library clients. Instead of _HelloWorld::PrinterImpl_ class an opaque _void*_ pointer is used
by the following automatic generated plain C functions:
~~~C
void* hello_world_printer_default()
{
    return new HelloWorld::PrinterImpl();
}

void hello_world_printer_show_const(void* object_pointer)
{
    const HelloWorld::PrinterImpl* self = static_cast<HelloWorld::PrinterImpl*>(object_pointer);
    self->Show();
}

void* hello_world_printer_copy(void* object_pointer)
{
    return new HelloWorld::PrinterImpl(*static_cast<HelloWorld::PrinterImpl*>(object_pointer));
}

void hello_world_printer_delete(void* object_pointer)
{
    delete static_cast<HelloWorld::PrinterImpl*>(object_pointer);
}
~~~

For simplicity we show only partial details here, we do not show details such as calling conventions or C linkage options for these functions.

Note that all plain C function names have *hello_world_* prefix which came from _HelloWorld_ namespace.
The second part of all plain C function names is *printer_* which came from the _Printer_ class name.
The remaining parts are method names.
Observe there are some simple rules for the conversion of any C++ identifier to a plain C function name.

And automatic generated C++ wrapper class:
~~~C++
namespace HelloWorld
{
    class Printer
    {
    public:
        Printer()
        {
            SetObject(hello_world_printer_default());
        }
        void Show() const
        {
            hello_world_printer_show_const(GetRawPointer());
        }
        Printer(const Printer& other)
        {
            if (other.GetRawPointer())
            {
                SetObject(hello_world_printer_copy(other.GetRawPointer()));
            }
            else
            {
                SetObject(0);
            }
        }
        ~Printer()
        {
            if (GetRawPointer())
            {
                hello_world_printer_delete(GetRawPointer());
                SetObject(0);
            }
        }
        void* GetRawPointer() const
        {
            return mObject;
        }
    protected:
        void SetObject(void* object_pointer)
        {
            mObject = object_pointer;
        }
        void* mObject;
    };
}
~~~

Of course, as author you need to manually create the following XML API description file to accompany the C++:
~~~XML
<?xml version="1.0" encoding="utf-8" ?>
<hello_world:api xmlns:hello_world="http://gkmsoft.ru/beautifulcapi" project_name="HelloWorld">
  <namespace name="HelloWorld">
    <class name="Printer" lifecycle="copy_semantic" implementation_class_name="HelloWorld::PrinterImpl" implementation_class_header="PrinterImpl.h">
      <constructor name="Default"/>
      <method name="Show" const="true"/>
    </class>
  </namespace>
</hello_world:api>
~~~

And sample usage of this class from client side:
~~~C++
#include <iostream>
#include <cstdlib>
#include "HelloWorld.h"

int main()
{
    HelloWorld::Printer printer;
    printer.Show();

    return EXIT_SUCCESS;
}
~~~

In this example _HelloWorld::PrinterImpl_ is the __implementation class__,
_HelloWorld::Printer_ is the __wrapper class__. In the XML API description file
_HelloWorld::Printer_ identifier could be
used for referencing this wrapped class and it is called __API identifier__ or just __identifier__.
In this example our wrapper class name is the same as the identifier, but in general they could be different.

Note that _HelloWorld::PrinterImpl_ class has copy semantic. This means that the implementation class object instances
are always copied when the wrapper class object instances are copied, and the implementation class object instances
are deleted when the wrapper class object instances are deleted. There are other possible behaviours.
In terms of this Beautiful Capi tool such behaviour is called __lifecycle semantic__.
Beautiful Capi supports several typical lifecycle semantics.

There is [hello_world](https://github.com/PetrPPetrov/beautiful-capi/tree/master/examples/hello_world) example
example which shows the first steps and the basic principles.

We can designate the following three code structure design concepts:
1. The __implementation side__. It means all code inside the C++ library, all classes,
functions, methods and other types inside the C++ library. The implementation classes are used in the C++ library.
Usually the C++ libraries are shared libraries which are intended to use by different C++ compilers.
2. The tiny __C glue layer__. The bodies of C glue functions are located inside the C++ library, in an automatically
generated .cpp file. In fact these functions are written in C++ (to have access to the implementation classes)
and just have C linkage option enabled. So, outside the C++ library these functions are seen as pure C functions.
Beautiful Capi generates both bodies of these functions and their declarations. The declarations are visible outside
of the C++ library.
3. The __wrap side__. It means all code generated by Beautiful Capi for clients of the C++ library, all classes,
functions, methods and other types inside any client of the C++ library. Clients of the C++ library
could be executable files, static libraries or shared libraries. The clients could be written in either pure
C language or in C++ language. The C++ clients usually use the generated wrapper classes. The C clients use pure
C functions directly. The wrapper classes are automatically generated by Beautiful Capi and visible only outside
of the C++ library, inside the C++ library the wrapper classes are unavailable.

Lifecycle semantics
-------------------

Beautiful Capi assumes that the implementation class object instances are always created on the heap.
This fact is applied for all lifecycle semantics.

You can specify lifecycle semantic for each wrapped class in the XML API description file.

### Copy semantic

Copy semantics means that the implementation class object instance is always copied when
the wrapper class object instance is copied. In other words, copy semantics emulates objects by value,
however, as we noted above, Beautiful Capi assumes that the implementation class object instances are always created
on the heap. So, Beautiful Capi generates a special *_copy* C API function and
the wrapper class calls the copy function.
~~~C
void* namespace_prefix_class_name_copy(void* object_pointer)
{
    return new ImplementationClass(*static_cast<ImplementationClass*>(object_pointer));
}
~~~

This works only if the copy constructor for implementation class is available. If a class has a copy semantic
then Beautiful Capi assumes that a copy constructor for the implementation class is available.
Currently this supposition is hard-coped inside the Beautiful Capi and can not be changed.

The copy C API function is used both within the wrapper class copy constructor and the assignment operator.

Copy semantic emulates objects by value, thus, the generated wrapper classes propose to use "." (the dot sign)
for accessing the wrapped class methods:
~~~C++
int main()
{
    // Creates the underlying implementation class on the heap of the C++ library
    HelloWorld::Printer printer;

    // Calls copy function to allocate new PrinterImpl class on the heap
    // of the C++ library by using PrinterImpl copy constructor.
    // printer and printer2 are different objects which have
    // different underlying implementation objects.
    HelloWorld::Printer printer2 = printer;

    // You have to use "." sign to access the wrapped PrinterImpl methods
    printer.Show();

    // At the end of this scope two PrinterImpl objects allocated on the heap
    // will be deallocated by using _delete function.
    // Please note that a heap manager of the C++ library will be used for that.
    return EXIT_SUCCESS;
}
~~~

The generated wrapper classes deallocate the underlying implementation class object instances by using a special
generated *_delete* C API function. This function has *_delete* suffix and looks like this:
~~~C
void namespace_prefix_class_name_delete(void* object_pointer)
{
    delete static_cast<ImplementationClass*>(object_pointer);
}
~~~

Delete C API function is called at the wrapper class destructor, thus memory leaks are nearly always eliminated.
There is [copy_semantic](https://github.com/PetrPPetrov/beautiful-capi/tree/master/examples/copy_semantic)
example which demonstrates this lifecycle semantic.

### Reference counted semantic

Reference counted semantics means that the implementation class has a reference counter.
The value of reference counter of the newly created objects should be equal 1.
When a new reference to the object is created then the reference counter is normally increased by 1.
When an existing reference to the object is destroyed then the reference counter is normally decreased by 1.
The objects themselves should be deleted when the reference counter become 0.

Beautiful Capi requires the availability of the following functions for the reference counted implementation classes:
~~~C++
void intrusive_ptr_add_ref(ImplementationClass* object);
void intrusive_ptr_release(ImplementationClass* object);
~~~

Beautiful Capi generates *_addref* and *_release* special C API functions which use the above declarations:
~~~C
void namespace_prefix_class_name_addref(void* object_pointer)
{
    intrusive_ptr_add_ref(static_cast<ImplementationClass*>(object_pointer));
}
void namespace_prefix_class_name_release(void* object_pointer)
{
    intrusive_ptr_release(static_cast<ImplementationClass*>(object_pointer));
}
~~~

The generated *_addref* C API function is used both in the wrapper class copy constructor and the assignment operator.
The wrapper class destructor calls the generated *_release* C API function.

The reference counted semantic does not require any copy constructors for the implementation classes,
thus allowing abstract C++ implementation classes to be used freely.

Reference counted semantic emulates object pointers (smart pointers). So, you should use "->" (the arrow)
for accessing the wrapped class methods, also the generated wrapper classes have *Ptr* suffix by default:
~~~C++
int main()
{
    // Creates the underlying implementation class on the heap of the C++ library.
    // Reference counter is 1.
    HelloWorld::PrinterPtr printer;

    // Calls _addref function to create a new reference to the existing object.
    // Reference counter is 2.
    // Both printer and printer2 reference to the same underlying implementation object.
    HelloWorld::PrinterPtr printer2 = printer;

    // You should use "->" to access wrapped PrinterImpl methods
    // However, "." sign is also could be used here, i.e.: printer.Show(); instruction will be compiled fine.
    // But we recommend you to always use "->".
    printer->Show();

    // At the end of this scope the PrinterImpl underlying implementation object will be deallocated.
    // This is because printer object destructor will decrease reference counter by 1 (from 2 to 1),
    // and printer2 object destructor will decrease reference counter by 1 (from 1 to 0),
    // and the underlying implementation object will be deallocated.
    // Please note that a heap manager of the C++ library will be used for that.
    return EXIT_SUCCESS;
}
~~~

There is a [reference_counted](https://github.com/PetrPPetrov/beautiful-capi/tree/master/examples/reference_counted)
example which demonstrates this lifecycle semantic.

### Raw pointer semantic

Raw pointer semantic does not have any special requirements to the implementation classes.
It emulates pointers (just raw pointers, not smart pointers). The generated wrapper classes do nothing at their
destructors, so you need to manually destroy the created underlying implementation objects to avoid memory leaks.

The generated wrapper classes have a special method for that, which usually has *Delete()* name by default.
You can customize this name, see [generation parameters XML schema](#generation-parameters-xml-schema).
The special *Delete()* method uses a special generated *_delete* C API function.
The generated *_delete* C API function is the same as the generated *_delete* C API function for copy semantic.

Raw pointer semantic emulates non-owning pointers. So, you should use "->" (the arrow)
for accessing the wrapped class methods, also the generated wrapper classes have *RawPtr* suffix by default:
~~~C++
int main()
{
    // Creates the underlying implementation class on the heap of the C++ library.
    HelloWorld::PrinterRawPtr printer;

    // Both printer and printer2 reference to the same underlying implementation object.
    HelloWorld::PrinterRawPtr printer2 = printer;

    // You should use "->" to access wrapped PrinterImpl methods
    // However, "." sign is also could be used here, i.e.: printer.Show(); instruction will be compiled fine.
    // But we recommend you to always use "->".
    printer->Show();

    // You need to manually deallocate the previously allocated PrinterImpl object.
    // Note that you need to deallocate it once by using either printer or printer2 object.
    // Here we used printer2 for deallocation, we could use printer instead, but not both.
    // This is because a double deallocation will happen in such a case.
    // Please note that a heap manager of the C++ library will be used for deallocation.
    printer2->Delete();

    return EXIT_SUCCESS;
}
~~~

There is a [raw_pointer_semantic](https://github.com/PetrPPetrov/beautiful-capi/tree/master/examples/raw_pointer_semantic)
example which demonstrates this lifecycle semantic.

### Common methods of the wrapper classes

If you need to create a wrapper class object which does not reference any underlying implementation object then
you can use *Null()* static method:
~~~C++
    HelloWorld::PrinterRawPtr null_pointer = HelloWorld::PrinterRawPtr::Null();
~~~

The same thing could be applied for all other semantics. This is because the underlying implementation objects are
always created on the library heap, and the wrapper classes just hold pointers:
~~~C++
    // Copy semantic
    HelloWorld::Printer null_printer = HelloWorld::Printer::Null();

    // Reference counted semantic
    HelloWorld::PrinterPtr null_printer_ptr = HelloWorld::PrinterPtr::Null();
~~~

There is an *IsNull()* helper method which returns _true_ if an internal pointer
to the underlying implementation object is null.
For convenience, there is an overloaded *operator!* in the wrapper classes, so, you can write the following code:
~~~C++
    HelloWorld::PrinterPtr printer_ptr = HelloWorld::PrinterPtr::Null();
    if (!printer)
    {
        std::cout << "printer_ptr is NULL" << std::endl;
    }
~~~

Classification of types
-----------------------

Conceptually Beautiful Capi distinguishes the following types:
* [Classes](#classes)
* [Mapped types](#mapped-types)
* [Enumeration types](#enumeration-types)
* [External classes](#external-classes)
* [Built-in types](#built-in-types) (not recommended to use)

### Classes

Beautiful Capi supports wrapping classes. Classes could have different lifecycle semantics.
It does not matter which lifecycle semantic has the object, it is always passed as *void**
in the C glue layer. This explicitly means that all object instances must be created on memory heap.
After passing the C glue layer the opaque *void** pointer should be casted to the implementation side type.
By default behaviour, if the class has reference counted semantic or raw pointer semantic then *void** type is
casted to pointer of the corresponding implementation type. If the class has copy semantic the default behaviour is
the same, but dereference operator (*) is applied additionally.

### Mapped types

Mapped types are designed for simple types like integers or floating numbers, strings, etc.
They are mostly the same as built-in types, but they contain additional information for wrapping.
Mapped types have information about types to use in the C glue layer, types to use on the implementation side, 
types to use on the wrap side, information how to make conversions between these types. We recommend to use
only fixed-length types for the C glue layer, like *int8_t*, *uint32_t*, etc. Also we recommend you to always
prefer mapped types rather than built-in types.

### Enumeration types

Enumeration types are similar to mapped types. However, conversions between the wrap side types and the C glue layer
types as well as conversions between the C glue layer types and the implementation side types are predefined.
Beautiful Capi assumes that enumeration types are integral types by its mature and uses *static_cast* simple casting
between types.

### External classes

External classes are classes from 3rd party library which is also wrapped by using Beautiful Capi tool.

### Built-in types

If type is not recognized as a class type, nor a mapped type, nor an enumeration type, nor an external class
then this type will be treated as a built-in type. For built-in types Beautiful Capi assumes that no special
type conversion is required, because the C glue layer type and the wrap side type and the implementation side type
are exactly the same type. Beautiful Capi just uses the specified type name as is, without any modifications or
any conversions of it.

We do not recommend to use built-in types, because different C++ or C compilers
could use different sizes of this types. We recommend to use mapped types instead. By default Beautiful Capi warns
if a built-in type is used.   

Mixing semantics
----------------

In real C++ programs some class could be used by different ways. These ways could be pointers to this class,
references, smart pointers and values. For each class Beautiful Capi XML API description specifies a semantic.
Sometimes it is not enough, because some implementation methods could accept references to this class,
other implementation methods could accept pointers to this class etc.

Beautiful Capi proposes two ways to solve this problem: the first way is [casting attributes](#casting-attributes),
and the second way is [lifecycle extensions](#lifecycle-extensions).

### Casting attributes

Casting attributes allow to perform some type castings. There are several types of casting attributes:
* _wrap_2_c_ specifies a custom type conversion string from the wrap side type to the C glue layer type 
* _c_2_wrap_ specifies a custom type conversion string from the C glue layer type to the wrap side type
* _c_2_impl_ specifies a custom type conversion string from the C glue layer type to the implementation side type
* _c_2_impl_mode_ specifies mode of conversion string from the C glue layer type to the implementation side type
* _impl_2_c_ specifies a custom type conversion string from the implementation side type to the C glue layer type

Each suctom conversion attribute is used as argument for Python 3 string.format() method call,
and you can use some predefined formal arguments in these strings:
* In _wrap_2_c_ attribute you can use _{expression}_ Python 3 string.format() formal argument. This formal argument
  will be replaced to a real expression which is converted from the wrap side to the C glue layer type.
* In _c_2_wrap_ attribute you can use _{expression}_ Python 3 string.format() formal argument. This formal argument
  will be replaced to a real expression which is converted from the C glue layer to the wrap side.

### Lifecycle extensions
TODO:

Exception handling
------------------

Beautiful Capi takes care about exceptions. As described above, in [C++ problems](#exceptions) section,
different C++ compilers have different exception throwing and catching schemas, also C language does not support
exceptions. The [*exception_handling_mode*](DescriptionParams.md#texceptionhandlingmode) attribute
in XML parameters file specifies mode for exception handling. Value *no_handling* means
that no special handling is done, so, any exception from the C++ library could crash
the client application in general, unless the client application and the C++ library use the same C++ compiler.

When *by_first_argument* value is used then exception information is passed in a special structure.
A pointer to this structure is added as the first argument to each function or method which could,
potentially, throw an exception. This structure has a following definition:
~~~C
struct beautiful_capi_exception_exception_info_t
{
    uint32_t code; /* value from beautiful_capi_exception_exception_code_t enumeration */
    void* object_pointer; /* exception object pointer */
};
~~~

The *object_pointer* field stores a pointer to exception object which was thrown. If no exception was thrown
then this field should contain zero.
Beautiful Capi assigns a code for each exception class. Exception class is a class which could be thrown as exception.
So, you need tell to Beautiful Capi which classes could be thrown as exceptions. In class description there is
*exception* boolean attribute and *true* means that a particular class could be thrown as exception.
The *code* field contains code of the thrown exception. Values below *100* are reserved by Beautiful Capi,
user exception classes have codes starting from *100*. Zero value means no exception,
*1* value means unknown exception, *2* value means unknown exception which raised during exception object copying.

Example of such codes:
~~~C
enum beautiful_capi_exception_exception_code_t
{
    no_exception = 0,
    unknown_exception = 1,
    copy_exception_error = 2,
    exception_generic = 100,
    exception_bad_argument = 101,
    exception_null_argument = 102,
    exception_division_by_zero = 103
};
~~~

There is [exception](https://github.com/PetrPPetrov/beautiful-capi/tree/master/examples/exception) example which
demonstrates exception information passing though dynamic library boundaries with different C runtime and compiler
environments and re-throwing exception on the client side. This example has four exception classes, one basic exception
class *Exception::Generic* (implementation name is *Exception::GenericImpl*, wrap name is *Exception::Generic*),
and three derived classes: *Exception::BadArgument* (implementation name is *Exception::BadArgumentImpl*),
*Exception::NullArgument* (implementation name is *Exception::NullArgumentImpl*) and *Exception::DivisionByZero*
(implementation name is *Exception::DivisionByZeroImpl*).

Basically Beautiful Capi catches exception inside the C++ library in the following manner:
~~~C++
EXCEPTION_API void* EXCEPTION_API_CONVENTION example_printer_new(beautiful_capi_exception_exception_info_t* exception_info)
{
    beautiful_capi_exception_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new Example::PrinterImpl();
    }
    catch (Exception::NullArgumentImpl& exception_object) // By reference
    {
        exception_info->code = 102;
        ...
    }
    catch (Exception::NullArgumentImpl* exception_object) // By pointer
    {
        exception_info->code = 102;
        exception_info->object_pointer = exception_object;
    }
    catch (Exception::BadArgumentImpl& exception_object) // By reference
    {
        exception_info->code = 101;
        ...
    }
    catch (Exception::BadArgumentImpl* exception_object) // By pointer
    {
        exception_info->code = 101;
        exception_info->object_pointer = exception_object;
    }
    catch (Exception::DivisionByZeroImpl& exception_object) // By value
    {
        exception_info->code = 103;
        ...
    }
    catch (Exception::DivisionByZeroImpl* exception_object) // By pointer
    {
        exception_info->code = 103;
        exception_info->object_pointer = exception_object;
    }
    catch (Exception::GenericImpl& exception_object) // By value
    {
        exception_info->code = 100;
        ...
    }
    catch (Exception::GenericImpl* exception_object) // By pointer
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}
~~~

And the generated code at the client side re-throws exception again, but using the wrap classes:
~~~C++
namespace beautiful_capi_Exception
{
    inline void check_and_throw_exception(uint32_t exception_code, void* exception_object)
    {
        switch (exception_code)
        {
            case 0:
                return;
            case 1:
                throw std::runtime_error("unknown exception");
            case 2:
                throw std::runtime_error("exception during copying exception object");
            case 100:
                throw Exception::Generic(Exception::Generic::force_creating_from_raw_pointer, exception_object, false);
            case 101:
                throw Exception::BadArgument(Exception::BadArgument::force_creating_from_raw_pointer, exception_object, false);
            case 102:
                throw Exception::NullArgument(Exception::NullArgument::force_creating_from_raw_pointer, exception_object, false);
            case 103:
                throw Exception::DivisionByZero(Exception::DivisionByZero::force_creating_from_raw_pointer, exception_object, false);
            default:
                assert(false);
                throw std::runtime_error("unknown exception code");
        }
    }
}
~~~

The generated above function is called each time in the generated wrap code:
~~~C++
inline Example::Printer::Printer()
{
    beautiful_capi_exception_exception_info_t exception_info;
    void* result(example_printer_new(&exception_info));
    beautiful_capi_Exception::check_and_throw_exception(exception_info.code, exception_info.object_pointer);
    SetObject(result);
}
~~~

For instance, if the C++ library will throw *Exception::NullArgumentImpl* class, it will be caught in the C glue layer,
and *code* field of the exception information structure will contain *exception_null_argument* (*102*) value,
*object_pointer* field will contain pointer to the exception object instance. Then *check_and_throw_exception()*
function will throw *Exception::NullArgument* wrap class on the client side, and, finally, this exception on the client
side could be caught as *Exception::Generic* or *Exception::NullArgument*.

In method and function descriptions there is *noexcept* flag which indicates that the specified method or function
does not throw any exceptions at all. Default value of this flag is *false*, but for destructors the default value of
this flag is *true*, because usually in C++ destructors don't throw any exceptions. If *noexcept* flag is *true*
then the specified function or method is processed in *no_handling* mode.

Also there are *copy_or_add_ref_noexcept* and *delete_or_release_noexcept* flags which indicate *noexcept* property
for Beautiful Capi generated *_copy* or *_add_ref* functions and *_delete* or *_release* functions respectively. These
flags could be used for class and callback descriptions.

There are plans (see [issue 12](https://github.com/PetrPPetrov/beautiful-capi/issues/12)) to mark functions and methods
which don't throw exceptions with C++ 11 *noexcept* keyword at the wrap side. However, such C++ 11 keyword
should be avoided for C++ compilers which don't support C++ 11 standard, because the wrap code could be compiled
by any C++ compiler.

Callbacks
---------
TODO:

Dynamic casts
-------------
TODO:

Templates
---------
TODO:

Snippets
--------
TODO:

Inheritance modes
-----------------
TODO:

Properties
----------
TODO:

Unit tests
----------
TODO:

Implementation code
-------------------
TODO:

Cascading libraries
-------------------
TODO:

Secured API
-----------
TODO:

Making compiler-independent libraries
-------------------------------------
TODO:

### Dynamic loader
TODO:

### Windows
TODO:

### Linux
TODO:

### MacOSX
TODO:

Command-line arguments
----------------------

The main script to execute Beautiful Capi generation is *source/Capi.py*.
If you run it with *--help* argument then you will have a similar output:
```
Beautiful Capi  Copyright (C) 2015  Petr Petrovich Petrov
This program comes with ABSOLUTELY NO WARRANTY;
This is free software, and you are welcome to redistribute it
under certain conditions.

usage: Beautiful Capi [-h] [-i INPUT] [-p PARAMS] [-o OUTPUT_FOLDER]
                      [-w OUTPUT_WRAP] [-s OUTPUT_SNIPPETS]
                      [-k API_KEYS_FOLDER] [-c] [-v] [-t UNIT_TESTS_FILE]

This program generates C and C++ wrappers for your C++ classes.

optional arguments:
  -h, --help            show this help message and exit
  -i INPUT, --input INPUT
                        specifies input API description file
  -p PARAMS, --params PARAMS
                        specifies generation parameters input file
  -o OUTPUT_FOLDER, --output-folder OUTPUT_FOLDER
                        specifies output folder for generated files
  -w OUTPUT_WRAP, --output-wrap-file-name OUTPUT_WRAP
                        specifies output file name for wrapper C-functions
  -s OUTPUT_SNIPPETS, --internal-snippets-folder OUTPUT_SNIPPETS
                        specifies output folder for generated library snippets
  -k API_KEYS_FOLDER, --api-keys-folder API_KEYS_FOLDER
                        specifies output folder for generated API keys
  -c, --clean           cleans input and snippets directories
  -v, --version         shows version number
  -t UNIT_TESTS_FILE, --tests-file UNIT_TESTS_FILE
                        generates unit tests for properties into specified
                        file
```

The input API description file format (__--input__ option) is described [here](#xml-api-description-schema).
The generation parameters input file (__--params__ option) has also XML format and its schema
is described [here](#xml-generation-parameters-schema).
The output folder (__--output-folder__ option) will contain the generated wrap classes
and other files for using on the wrap side.
The output file name for wrapper C-functions (__--output-wrap-file-name__ option) will contain
the C glue layer function bodies, this file have to be a part of the C++ library.
The output folder for generated library snippets (__--internal-snippets-folder__ option) will contain the generated
snippets. For details about snippets please read [snippets](#snippets) section.
The output folder for generated API keys (__--api-keys-folder__ option)
will contain the generated keys for the C++ library secured API,
more details please see in [secured API](#secured-api) section.
The tests file (__--tests-file__ option) specifies output file for the generated unit tests,
please see [unit tests](#unit-tests) section.

Integration with CMake
----------------------

Basically integration with [CMake](https://cmake.org/) could be done by using *add_custom_command*.
```
    add_custom_command(
        OUTPUT
            ${CMAKE_CURRENT_SOURCE_DIR}/AutoGenWrap.cpp
        COMMAND
            ${PYTHON_EXECUTABLE}
            ${beautiful_capi_SOURCE_DIR}/source/Capi.py
            -i ${CMAKE_CURRENT_SOURCE_DIR}/SampleAPI.xml
            -p ${CMAKE_CURRENT_SOURCE_DIR}/SampleAPI_params.xml
            -o ${CMAKE_CURRENT_SOURCE_DIR}/include
            -s ${CMAKE_CURRENT_SOURCE_DIR}/snippets
            -w ${generated_source}
        MAIN_DEPENDENCY
            ${CMAKE_CURRENT_SOURCE_DIR}/SampleAPI.xml
        DEPENDS
            ${CMAKE_CURRENT_SOURCE_DIR}/SampleAPI_params.xml
        WORKING_DIRECTORY
            ${CMAKE_CURRENT_SOURCE_DIR}
    )
```

But you should find Python3 interpreter before:
```
find_package(PythonInterp 3.4 REQUIRED)
```

Also you need to include *AutoGenWrap.cpp* to *SampleAPI* library:
```
add_library(SampleAPI SHARED
  ${CMAKE_CURRENT_SOURCE_DIR}/AutoGenWrap.cpp
  ...other files...
)
```

Important: You must do not insert the output folder for generated wrap classes to the library's *include* path.
But you can do this with *snippets* folder.

XML API description schema
--------------------------

The wrapped C++ library API is described in the portable XML format for the exposed API
by using [this schema](https://github.com/PetrPPetrov/beautiful-capi/blob/master/source/Capi.xsd).
This schema uses *http://gkmsoft.ru/beautifulcapi* XSD namespace.

The detailed description of this schema is [here](DescriptionSchema.md).
The root element is *api* which has [*TBeautifulCapiRoot*](DescriptionSchema.md#tbeautifulcapiroot) XSD type.

XML generation parameters schema
--------------------------------

The Beautiful Capi generator has parameters in XML format,
which has [this](https://github.com/PetrPPetrov/beautiful-capi/blob/master/source/CapiParams.xsd) schema.
This schema uses *http://gkmsoft.ru/beautifulcapi-params* XSD namespace.

The detailed description of this schema is [here](DescriptionParams.md).
The root element is *params* which has [*TBeautifulCapiParams*](DescriptionParams.md#tbeautifulcapiparams) XSD type.
