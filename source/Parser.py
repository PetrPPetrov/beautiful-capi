#!/usr/bin/env python
#
# Beautiful Capi generates beautiful C API wrappers for your C++ classes
# Copyright (C) 2015 Petr Petrovich Petrov
#
# This file is part of Beautiful Capi.
#
# Beautiful Capi is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Beautiful Capi is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Beautiful Capi.  If not, see <http://www.gnu.org/licenses/>.
#


#
# WARNING: This file was automatically generated by Xsd2Python3.py program!
# Do not edit this file! Please edit the source XSD schema.
#


from enum import Enum


def string_to_bool(string_value):
    return string_value.lower() in ['true', 'on', 'yes', '1']


def string_to_int(string_value):
    return int(string_value)


class TLifecycle(Enum):
    copy_semantic = 0
    raw_pointer_semantic = 1
    reference_counted = 2

    @staticmethod
    def load(value):
        if value == "copy_semantic":
            return TLifecycle.copy_semantic
        if value == "raw_pointer_semantic":
            return TLifecycle.raw_pointer_semantic
        if value == "reference_counted":
            return TLifecycle.reference_counted
        raise ValueError


class TC2ImplMode(Enum):
    default = 0
    to_pointer = 1
    to_value = 2

    @staticmethod
    def load(value):
        if value == "default":
            return TC2ImplMode.default
        if value == "to_pointer":
            return TC2ImplMode.to_pointer
        if value == "to_value":
            return TC2ImplMode.to_value
        raise ValueError


class TOverloadSuffixMode(Enum):
    Off = 0
    Notify = 1
    Silent = 2

    @staticmethod
    def load(value):
        if value == "Off":
            return TOverloadSuffixMode.Off
        if value == "Notify":
            return TOverloadSuffixMode.Notify
        if value == "Silent":
            return TOverloadSuffixMode.Silent
        raise ValueError


class TBeautifulCapiRoot(object):
    def __init__(self):
        self.all_items = []
        self.project_name = ""
        self.project_name_filled = False
        self.major_version = 1
        self.major_version_filled = False
        self.minor_version = 0
        self.minor_version_filled = False
        self.patch_version = 0
        self.patch_version_filled = False
        self.namespaces = []

    def load_element(self, element):
        if element.nodeName == "namespace":
            new_element = TNamespace()
            new_element.load(element)
            self.namespaces.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("project_name"):
            cur_attr = dom_node.getAttribute("project_name")
            self.project_name = cur_attr
            self.project_name_filled = True
        if dom_node.hasAttribute("major_version"):
            cur_attr = dom_node.getAttribute("major_version")
            self.major_version = string_to_int(cur_attr)
            self.major_version_filled = True
        if dom_node.hasAttribute("minor_version"):
            cur_attr = dom_node.getAttribute("minor_version")
            self.minor_version = string_to_int(cur_attr)
            self.minor_version_filled = True
        if dom_node.hasAttribute("patch_version"):
            cur_attr = dom_node.getAttribute("patch_version")
            self.patch_version = string_to_int(cur_attr)
            self.patch_version_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TNamespace(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.implementation_header = ""
        self.implementation_header_filled = False
        self.overload_suffix_mode = TOverloadSuffixMode.Notify
        self.overload_suffix_mode_filled = False
        self.documentations = []
        self.external_namespaces = []
        self.external_libraries = []
        self.includes = []
        self.namespaces = []
        self.include_headers = []
        self.enumerations = []
        self.classes = []
        self.functions = []
        self.templates = []
        self.property_set_prefixes = []
        self.property_get_prefixes = []
        self.property_get_consts = []
        self.mapped_types = []

    def load_element(self, element):
        if element.nodeName == "documentation":
            new_element = TDocumentation()
            new_element.load(element)
            self.documentations.append(new_element)
            return True
        if element.nodeName == "external_namespace":
            new_element = TExternalNamespace()
            new_element.load(element)
            self.external_namespaces.append(new_element)
            return True
        if element.nodeName == "external_library":
            new_element = TExternalLibrary()
            new_element.load(element)
            self.external_libraries.append(new_element)
            return True
        if element.nodeName == "include":
            new_element = TApiInclude()
            new_element.load(element)
            self.includes.append(new_element)
            return True
        if element.nodeName == "namespace":
            new_element = TNamespace()
            new_element.load(element)
            self.namespaces.append(new_element)
            return True
        if element.nodeName == "include_header":
            new_element = THeaderInclude()
            new_element.load(element)
            self.include_headers.append(new_element)
            return True
        if element.nodeName == "enumeration":
            new_element = TEnumeration()
            new_element.load(element)
            self.enumerations.append(new_element)
            return True
        if element.nodeName == "class":
            new_element = TClass()
            new_element.load(element)
            self.classes.append(new_element)
            return True
        if element.nodeName == "function":
            new_element = TFunction()
            new_element.load(element)
            self.functions.append(new_element)
            return True
        if element.nodeName == "template":
            new_element = TTemplate()
            new_element.load(element)
            self.templates.append(new_element)
            return True
        if element.nodeName == "property_set_prefix":
            new_element = TPropertySetPrefix()
            new_element.load(element)
            self.property_set_prefixes.append(new_element)
            return True
        if element.nodeName == "property_get_prefix":
            new_element = TPropertyGetPrefix()
            new_element.load(element)
            self.property_get_prefixes.append(new_element)
            return True
        if element.nodeName == "property_get_const":
            new_element = TPropertyGetConst()
            new_element.load(element)
            self.property_get_consts.append(new_element)
            return True
        if element.nodeName == "mapped_type":
            new_element = TMappedType()
            new_element.load(element)
            self.mapped_types.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("implementation_header"):
            cur_attr = dom_node.getAttribute("implementation_header")
            self.implementation_header = cur_attr
            self.implementation_header_filled = True
        if dom_node.hasAttribute("overload_suffix_mode"):
            cur_attr = dom_node.getAttribute("overload_suffix_mode")
            self.overload_suffix_mode = TOverloadSuffixMode.load(cur_attr)
            self.overload_suffix_mode_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TGenericDocumentation(object):
    def __init__(self):
        self.all_items = []
        self.references = []
        self.see_alsos = []

    def load_element(self, element):
        if element.nodeName == "reference":
            new_element = TReference()
            new_element.load(element)
            self.references.append(new_element)
            self.all_items.append(new_element)
            return True
        if element.nodeName == "see_also":
            new_element = TGenericDocumentation()
            new_element.load(element)
            self.see_alsos.append(new_element)
            self.all_items.append(new_element)
            return True
        if element.nodeType == element.TEXT_NODE:
            cur_texts = [text.strip() for text in element.data.split('\n')]
            first = True
            for text in cur_texts:
                if first and self.all_items and type(self.all_items[-1]) is str:
                    self.all_items[-1] += text
                else:
                    self.all_items.append(text)
                first = False
            return True
        return False

    def load_attributes(self, dom_node):
        pass

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TDocumentation(TGenericDocumentation):
    def __init__(self):
        super().__init__()
        self.briefs = []
        self.returns = []

    def load_element(self, element):
        if super().load_element(element):
            return True
        if element.nodeName == "brief":
            new_element = TGenericDocumentation()
            new_element.load(element)
            self.briefs.append(new_element)
            self.all_items.append(new_element)
            return True
        if element.nodeName == "returns":
            new_element = TGenericDocumentation()
            new_element.load(element)
            self.returns.append(new_element)
            self.all_items.append(new_element)
            return True
        if element.nodeType == element.TEXT_NODE:
            cur_texts = [text.strip() for text in element.data.split('\n')]
            first = True
            for text in cur_texts:
                if first and self.all_items and type(self.all_items[-1]) is str:
                    self.all_items[-1] += text
                else:
                    self.all_items.append(text)
                first = False
            return True
        return False

    def load_attributes(self, dom_node):
        super().load_attributes(dom_node)

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TReference(object):
    def __init__(self):
        self.all_items = []

    def load_element(self, element):
        if element.nodeType == element.TEXT_NODE:
            cur_texts = [text.strip() for text in element.data.split('\n')]
            first = True
            for text in cur_texts:
                if first and self.all_items and type(self.all_items[-1]) is str:
                    self.all_items[-1] += text
                else:
                    self.all_items.append(text)
                first = False
            return True
        return False

    def load_attributes(self, dom_node):
        pass

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TExternalNamespace(object):
    def __init__(self):
        self.all_items = []
        self.include = ""
        self.include_filled = False
        self.name = ""
        self.name_filled = False
        self.detach_method_name = "Detach"
        self.detach_method_name_filled = False
        self.get_raw_pointer_method_name = "GetRawPointer"
        self.get_raw_pointer_method_name_filled = False
        self.classes = []
        self.namespaces = []

    def load_element(self, element):
        if element.nodeName == "class":
            new_element = TExternalClass()
            new_element.load(element)
            self.classes.append(new_element)
            return True
        if element.nodeName == "namespace":
            new_element = TExternalNamespace()
            new_element.load(element)
            self.namespaces.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("include"):
            cur_attr = dom_node.getAttribute("include")
            self.include = cur_attr
            self.include_filled = True
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("detach_method_name"):
            cur_attr = dom_node.getAttribute("detach_method_name")
            self.detach_method_name = cur_attr
            self.detach_method_name_filled = True
        if dom_node.hasAttribute("get_raw_pointer_method_name"):
            cur_attr = dom_node.getAttribute("get_raw_pointer_method_name")
            self.get_raw_pointer_method_name = cur_attr
            self.get_raw_pointer_method_name_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TExternalClass(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.wrap_name = ""
        self.wrap_name_filled = False
        self.include_declaration = ""
        self.include_declaration_filled = False
        self.include_definition = ""
        self.include_definition_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("wrap_name"):
            cur_attr = dom_node.getAttribute("wrap_name")
            self.wrap_name = cur_attr
            self.wrap_name_filled = True
        if dom_node.hasAttribute("include_declaration"):
            cur_attr = dom_node.getAttribute("include_declaration")
            self.include_declaration = cur_attr
            self.include_declaration_filled = True
        if dom_node.hasAttribute("include_definition"):
            cur_attr = dom_node.getAttribute("include_definition")
            self.include_definition = cur_attr
            self.include_definition_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TExternalLibrary(object):
    def __init__(self):
        self.all_items = []
        self.input_xml_file = ""
        self.input_xml_file_filled = False
        self.params_xml_file = ""
        self.params_xml_file_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("input_xml_file"):
            cur_attr = dom_node.getAttribute("input_xml_file")
            self.input_xml_file = cur_attr
            self.input_xml_file_filled = True
        if dom_node.hasAttribute("params_xml_file"):
            cur_attr = dom_node.getAttribute("params_xml_file")
            self.params_xml_file = cur_attr
            self.params_xml_file_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TApiInclude(object):
    def __init__(self):
        self.all_items = []
        self.path = ""
        self.path_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("path"):
            cur_attr = dom_node.getAttribute("path")
            self.path = cur_attr
            self.path_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TEnumerationItem(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.value = ""
        self.value_filled = False
        self.documentations = []

    def load_element(self, element):
        if element.nodeName == "documentation":
            new_element = TGenericDocumentation()
            new_element.load(element)
            self.documentations.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("value"):
            cur_attr = dom_node.getAttribute("value")
            self.value = cur_attr
            self.value_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TEnumeration(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.underlying_type = ""
        self.underlying_type_filled = False
        self.documentations = []
        self.items = []

    def load_element(self, element):
        if element.nodeName == "documentation":
            new_element = TDocumentation()
            new_element.load(element)
            self.documentations.append(new_element)
            return True
        if element.nodeName == "item":
            new_element = TEnumerationItem()
            new_element.load(element)
            self.items.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("underlying_type"):
            cur_attr = dom_node.getAttribute("underlying_type")
            self.underlying_type = cur_attr
            self.underlying_type_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TTemplate(object):
    def __init__(self):
        self.all_items = []
        self.arguments = []
        self.instantiations = []
        self.classes = []

    def load_element(self, element):
        if element.nodeName == "argument":
            new_element = TArgument()
            new_element.load(element)
            self.arguments.append(new_element)
            return True
        if element.nodeName == "instantiation":
            new_element = TInstantiation()
            new_element.load(element)
            self.instantiations.append(new_element)
            return True
        if element.nodeName == "class":
            new_element = TClass()
            new_element.load(element)
            self.classes.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        pass

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TInstantiation(object):
    def __init__(self):
        self.all_items = []
        self.typedef_name = ""
        self.typedef_name_filled = False
        self.implementation_class_name = ""
        self.implementation_class_name_filled = False
        self.arguments = []

    def load_element(self, element):
        if element.nodeName == "argument":
            new_element = TInstantiationArgument()
            new_element.load(element)
            self.arguments.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("typedef_name"):
            cur_attr = dom_node.getAttribute("typedef_name")
            self.typedef_name = cur_attr
            self.typedef_name_filled = True
        if dom_node.hasAttribute("implementation_class_name"):
            cur_attr = dom_node.getAttribute("implementation_class_name")
            self.implementation_class_name = cur_attr
            self.implementation_class_name_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TInstantiationArgument(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.value = ""
        self.value_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("value"):
            cur_attr = dom_node.getAttribute("value")
            self.value = cur_attr
            self.value_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TClass(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.base = ""
        self.base_filled = False
        self.implementation_class_name = ""
        self.implementation_class_name_filled = False
        self.snippet_type = ""
        self.snippet_type_filled = False
        self.abstract = False
        self.abstract_filled = False
        self.implementation_class_header = ""
        self.implementation_class_header_filled = False
        self.lifecycle = TLifecycle.reference_counted
        self.lifecycle_filled = False
        self.requires_cast_to_base = True
        self.requires_cast_to_base_filled = False
        self.pointer_access = False
        self.pointer_access_filled = False
        self.exception = False
        self.exception_filled = False
        self.template_line = ""
        self.template_line_filled = False
        self.typedef_name = ""
        self.typedef_name_filled = False
        self.copy_or_add_ref_noexcept = False
        self.copy_or_add_ref_noexcept_filled = False
        self.delete_or_release_noexcept = True
        self.delete_or_release_noexcept_filled = False
        self.overload_suffix_mode = TOverloadSuffixMode.Notify
        self.overload_suffix_mode_filled = False
        self.wrap_name = "{class_name}{wrap_suffix}"
        self.wrap_name_filled = False
        self.generate_copy_constructor = True
        self.generate_copy_constructor_filled = False
        self.impl_2_c = ""
        self.impl_2_c_filled = False
        self.c_2_impl = ""
        self.c_2_impl_filled = False
        self.custom_cast_to_base = ""
        self.custom_cast_to_base_filled = False
        self.custom_down_cast = ""
        self.custom_down_cast_filled = False
        self.down_cast = True
        self.down_cast_filled = False
        self.documentations = []
        self.include_headers = []
        self.enumerations = []
        self.constructors = []
        self.properties = []
        self.methods = []
        self.callbacks = []
        self.mapped_types = []
        self.lifecycle_extensions = []

    def load_element(self, element):
        if element.nodeName == "documentation":
            new_element = TDocumentation()
            new_element.load(element)
            self.documentations.append(new_element)
            return True
        if element.nodeName == "include_header":
            new_element = THeaderInclude()
            new_element.load(element)
            self.include_headers.append(new_element)
            return True
        if element.nodeName == "enumeration":
            new_element = TEnumeration()
            new_element.load(element)
            self.enumerations.append(new_element)
            return True
        if element.nodeName == "constructor":
            new_element = TConstructor()
            new_element.load(element)
            self.constructors.append(new_element)
            return True
        if element.nodeName == "property":
            new_element = TProperty()
            new_element.load(element)
            self.properties.append(new_element)
            return True
        if element.nodeName == "method":
            new_element = TMethod()
            new_element.load(element)
            self.methods.append(new_element)
            return True
        if element.nodeName == "callback":
            new_element = TCallback()
            new_element.load(element)
            self.callbacks.append(new_element)
            return True
        if element.nodeName == "mapped_type":
            new_element = TMappedType()
            new_element.load(element)
            self.mapped_types.append(new_element)
            return True
        if element.nodeName == "lifecycle_extension":
            new_element = TLifecycleExtension()
            new_element.load(element)
            self.lifecycle_extensions.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("base"):
            cur_attr = dom_node.getAttribute("base")
            self.base = cur_attr
            self.base_filled = True
        if dom_node.hasAttribute("implementation_class_name"):
            cur_attr = dom_node.getAttribute("implementation_class_name")
            self.implementation_class_name = cur_attr
            self.implementation_class_name_filled = True
        if dom_node.hasAttribute("snippet_type"):
            cur_attr = dom_node.getAttribute("snippet_type")
            self.snippet_type = cur_attr
            self.snippet_type_filled = True
        if dom_node.hasAttribute("abstract"):
            cur_attr = dom_node.getAttribute("abstract")
            self.abstract = string_to_bool(cur_attr)
            self.abstract_filled = True
        if dom_node.hasAttribute("implementation_class_header"):
            cur_attr = dom_node.getAttribute("implementation_class_header")
            self.implementation_class_header = cur_attr
            self.implementation_class_header_filled = True
        if dom_node.hasAttribute("lifecycle"):
            cur_attr = dom_node.getAttribute("lifecycle")
            self.lifecycle = TLifecycle.load(cur_attr)
            self.lifecycle_filled = True
        if dom_node.hasAttribute("requires_cast_to_base"):
            cur_attr = dom_node.getAttribute("requires_cast_to_base")
            self.requires_cast_to_base = string_to_bool(cur_attr)
            self.requires_cast_to_base_filled = True
        if dom_node.hasAttribute("pointer_access"):
            cur_attr = dom_node.getAttribute("pointer_access")
            self.pointer_access = string_to_bool(cur_attr)
            self.pointer_access_filled = True
        if dom_node.hasAttribute("exception"):
            cur_attr = dom_node.getAttribute("exception")
            self.exception = string_to_bool(cur_attr)
            self.exception_filled = True
        if dom_node.hasAttribute("template_line"):
            cur_attr = dom_node.getAttribute("template_line")
            self.template_line = cur_attr
            self.template_line_filled = True
        if dom_node.hasAttribute("typedef_name"):
            cur_attr = dom_node.getAttribute("typedef_name")
            self.typedef_name = cur_attr
            self.typedef_name_filled = True
        if dom_node.hasAttribute("copy_or_add_ref_noexcept"):
            cur_attr = dom_node.getAttribute("copy_or_add_ref_noexcept")
            self.copy_or_add_ref_noexcept = string_to_bool(cur_attr)
            self.copy_or_add_ref_noexcept_filled = True
        if dom_node.hasAttribute("delete_or_release_noexcept"):
            cur_attr = dom_node.getAttribute("delete_or_release_noexcept")
            self.delete_or_release_noexcept = string_to_bool(cur_attr)
            self.delete_or_release_noexcept_filled = True
        if dom_node.hasAttribute("overload_suffix_mode"):
            cur_attr = dom_node.getAttribute("overload_suffix_mode")
            self.overload_suffix_mode = TOverloadSuffixMode.load(cur_attr)
            self.overload_suffix_mode_filled = True
        if dom_node.hasAttribute("wrap_name"):
            cur_attr = dom_node.getAttribute("wrap_name")
            self.wrap_name = cur_attr
            self.wrap_name_filled = True
        if dom_node.hasAttribute("generate_copy_constructor"):
            cur_attr = dom_node.getAttribute("generate_copy_constructor")
            self.generate_copy_constructor = string_to_bool(cur_attr)
            self.generate_copy_constructor_filled = True
        if dom_node.hasAttribute("impl_2_c"):
            cur_attr = dom_node.getAttribute("impl_2_c")
            self.impl_2_c = cur_attr
            self.impl_2_c_filled = True
        if dom_node.hasAttribute("c_2_impl"):
            cur_attr = dom_node.getAttribute("c_2_impl")
            self.c_2_impl = cur_attr
            self.c_2_impl_filled = True
        if dom_node.hasAttribute("custom_cast_to_base"):
            cur_attr = dom_node.getAttribute("custom_cast_to_base")
            self.custom_cast_to_base = cur_attr
            self.custom_cast_to_base_filled = True
        if dom_node.hasAttribute("custom_down_cast"):
            cur_attr = dom_node.getAttribute("custom_down_cast")
            self.custom_down_cast = cur_attr
            self.custom_down_cast_filled = True
        if dom_node.hasAttribute("down_cast"):
            cur_attr = dom_node.getAttribute("down_cast")
            self.down_cast = string_to_bool(cur_attr)
            self.down_cast_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TCallback(object):
    def __init__(self):
        self.all_items = []
        self.lifecycle = TLifecycle.reference_counted
        self.lifecycle_filled = False
        self.copy_or_add_ref_noexcept = False
        self.copy_or_add_ref_noexcept_filled = False
        self.delete_or_release_noexcept = True
        self.delete_or_release_noexcept_filled = False
        self.implementation_class_name = ""
        self.implementation_class_name_filled = False
        self.implementation_class_header = ""
        self.implementation_class_header_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("lifecycle"):
            cur_attr = dom_node.getAttribute("lifecycle")
            self.lifecycle = TLifecycle.load(cur_attr)
            self.lifecycle_filled = True
        if dom_node.hasAttribute("copy_or_add_ref_noexcept"):
            cur_attr = dom_node.getAttribute("copy_or_add_ref_noexcept")
            self.copy_or_add_ref_noexcept = string_to_bool(cur_attr)
            self.copy_or_add_ref_noexcept_filled = True
        if dom_node.hasAttribute("delete_or_release_noexcept"):
            cur_attr = dom_node.getAttribute("delete_or_release_noexcept")
            self.delete_or_release_noexcept = string_to_bool(cur_attr)
            self.delete_or_release_noexcept_filled = True
        if dom_node.hasAttribute("implementation_class_name"):
            cur_attr = dom_node.getAttribute("implementation_class_name")
            self.implementation_class_name = cur_attr
            self.implementation_class_name_filled = True
        if dom_node.hasAttribute("implementation_class_header"):
            cur_attr = dom_node.getAttribute("implementation_class_header")
            self.implementation_class_header = cur_attr
            self.implementation_class_header_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TConstructorBase(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.return_copy_or_add_ref = False
        self.return_copy_or_add_ref_filled = False
        self.noexcept = False
        self.noexcept_filled = False
        self.documentations = []
        self.arguments = []

    def load_element(self, element):
        if element.nodeName == "documentation":
            new_element = TDocumentation()
            new_element.load(element)
            self.documentations.append(new_element)
            return True
        if element.nodeName == "argument":
            new_element = TArgument()
            new_element.load(element)
            self.arguments.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("return_copy_or_add_ref"):
            cur_attr = dom_node.getAttribute("return_copy_or_add_ref")
            self.return_copy_or_add_ref = string_to_bool(cur_attr)
            self.return_copy_or_add_ref_filled = True
        if dom_node.hasAttribute("noexcept"):
            cur_attr = dom_node.getAttribute("noexcept")
            self.noexcept = string_to_bool(cur_attr)
            self.noexcept_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TConstructor(TConstructorBase):
    def __init__(self):
        super().__init__()
        self.explicit = False
        self.explicit_filled = False

    def load_element(self, element):
        if super().load_element(element):
            return True
        return False

    def load_attributes(self, dom_node):
        super().load_attributes(dom_node)
        if dom_node.hasAttribute("explicit"):
            cur_attr = dom_node.getAttribute("explicit")
            self.explicit = string_to_bool(cur_attr)
            self.explicit_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TImplementationCode(object):
    def __init__(self):
        self.all_items = []

    def load_element(self, element):
        if element.nodeType == element.TEXT_NODE:
            cur_texts = [text.strip() for text in element.data.split('\n')]
            first = True
            for text in cur_texts:
                if first and self.all_items and type(self.all_items[-1]) is str:
                    self.all_items[-1] += text
                else:
                    self.all_items.append(text)
                first = False
            return True
        return False

    def load_attributes(self, dom_node):
        pass

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TMethodBase(TConstructorBase):
    def __init__(self):
        super().__init__()
        self.return_type = ""
        self.return_type_filled = False
        self.return_is_builtin = False
        self.return_is_builtin_filled = False
        self.overload_suffix = ""
        self.overload_suffix_filled = False
        self.impl_2_c = "new {implementation_type}({expression})"
        self.impl_2_c_filled = False
        self.implementation_name = ""
        self.implementation_name_filled = False
        self.implementation_codes = []

    def load_element(self, element):
        if super().load_element(element):
            return True
        if element.nodeName == "implementation_code":
            new_element = TImplementationCode()
            new_element.load(element)
            self.implementation_codes.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        super().load_attributes(dom_node)
        if dom_node.hasAttribute("return"):
            cur_attr = dom_node.getAttribute("return")
            self.return_type = cur_attr
            self.return_type_filled = True
        if dom_node.hasAttribute("return_is_builtin"):
            cur_attr = dom_node.getAttribute("return_is_builtin")
            self.return_is_builtin = string_to_bool(cur_attr)
            self.return_is_builtin_filled = True
        if dom_node.hasAttribute("overload_suffix"):
            cur_attr = dom_node.getAttribute("overload_suffix")
            self.overload_suffix = cur_attr
            self.overload_suffix_filled = True
        if dom_node.hasAttribute("impl_2_c"):
            cur_attr = dom_node.getAttribute("impl_2_c")
            self.impl_2_c = cur_attr
            self.impl_2_c_filled = True
        if dom_node.hasAttribute("implementation_name"):
            cur_attr = dom_node.getAttribute("implementation_name")
            self.implementation_name = cur_attr
            self.implementation_name_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TMethod(TMethodBase):
    def __init__(self):
        super().__init__()
        self.const = False
        self.const_filled = False

    def load_element(self, element):
        if super().load_element(element):
            return True
        return False

    def load_attributes(self, dom_node):
        super().load_attributes(dom_node)
        if dom_node.hasAttribute("const"):
            cur_attr = dom_node.getAttribute("const")
            self.const = string_to_bool(cur_attr)
            self.const_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TFunction(TMethodBase):
    def __init__(self):
        super().__init__()
        self.implementation_header = ""
        self.implementation_header_filled = False

    def load_element(self, element):
        if super().load_element(element):
            return True
        return False

    def load_attributes(self, dom_node):
        super().load_attributes(dom_node)
        if dom_node.hasAttribute("implementation_header"):
            cur_attr = dom_node.getAttribute("implementation_header")
            self.implementation_header = cur_attr
            self.implementation_header_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TArgument(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.type_name = ""
        self.type_name_filled = False
        self.is_builtin = False
        self.is_builtin_filled = False
        self.c_2_impl = "static_cast<{implementation_type}*>({expression})"
        self.c_2_impl_filled = False
        self.c_2_impl_mode = TC2ImplMode.default
        self.c_2_impl_mode_filled = False
        self.documentations = []

    def load_element(self, element):
        if element.nodeName == "documentation":
            new_element = TGenericDocumentation()
            new_element.load(element)
            self.documentations.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("type"):
            cur_attr = dom_node.getAttribute("type")
            self.type_name = cur_attr
            self.type_name_filled = True
        if dom_node.hasAttribute("is_builtin"):
            cur_attr = dom_node.getAttribute("is_builtin")
            self.is_builtin = string_to_bool(cur_attr)
            self.is_builtin_filled = True
        if dom_node.hasAttribute("c_2_impl"):
            cur_attr = dom_node.getAttribute("c_2_impl")
            self.c_2_impl = cur_attr
            self.c_2_impl_filled = True
        if dom_node.hasAttribute("c_2_impl_mode"):
            cur_attr = dom_node.getAttribute("c_2_impl_mode")
            self.c_2_impl_mode = TC2ImplMode.load(cur_attr)
            self.c_2_impl_mode_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TLifecycleExtension(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.wrap_name = ""
        self.wrap_name_filled = False
        self.lifecycle = TLifecycle.copy_semantic
        self.lifecycle_filled = False
        self.down_cast = False
        self.down_cast_filled = False
        self.cast_tos = []
        self.cast_froms = []

    def load_element(self, element):
        if element.nodeName == "cast_to":
            new_element = TCastTo()
            new_element.load(element)
            self.cast_tos.append(new_element)
            return True
        if element.nodeName == "cast_from":
            new_element = TCastFrom()
            new_element.load(element)
            self.cast_froms.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("wrap_name"):
            cur_attr = dom_node.getAttribute("wrap_name")
            self.wrap_name = cur_attr
            self.wrap_name_filled = True
        if dom_node.hasAttribute("lifecycle"):
            cur_attr = dom_node.getAttribute("lifecycle")
            self.lifecycle = TLifecycle.load(cur_attr)
            self.lifecycle_filled = True
        if dom_node.hasAttribute("down_cast"):
            cur_attr = dom_node.getAttribute("down_cast")
            self.down_cast = string_to_bool(cur_attr)
            self.down_cast_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TCastTo(object):
    def __init__(self):
        self.all_items = []
        self.implicit = True
        self.implicit_filled = False
        self.target_type = ""
        self.target_type_filled = False
        self.cast_method = "To{target_type}"
        self.cast_method_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("implicit"):
            cur_attr = dom_node.getAttribute("implicit")
            self.implicit = string_to_bool(cur_attr)
            self.implicit_filled = True
        if dom_node.hasAttribute("target_type"):
            cur_attr = dom_node.getAttribute("target_type")
            self.target_type = cur_attr
            self.target_type_filled = True
        if dom_node.hasAttribute("cast_method"):
            cur_attr = dom_node.getAttribute("cast_method")
            self.cast_method = cur_attr
            self.cast_method_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TCastFrom(object):
    def __init__(self):
        self.all_items = []
        self.source_type = ""
        self.source_type_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("source_type"):
            cur_attr = dom_node.getAttribute("source_type")
            self.source_type = cur_attr
            self.source_type_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class THeaderInclude(object):
    def __init__(self):
        self.all_items = []
        self.file = ""
        self.file_filled = False
        self.system = False
        self.system_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("file"):
            cur_attr = dom_node.getAttribute("file")
            self.file = cur_attr
            self.file_filled = True
        if dom_node.hasAttribute("system"):
            cur_attr = dom_node.getAttribute("system")
            self.system = string_to_bool(cur_attr)
            self.system_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TProperty(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.type_name = ""
        self.type_name_filled = False
        self.set_prefix = "Set"
        self.set_prefix_filled = False
        self.get_prefix = "Get"
        self.get_prefix_filled = False
        self.get_const = True
        self.get_const_filled = False
        self.set_argument_name = ""
        self.set_argument_name_filled = False
        self.is_builtin = False
        self.is_builtin_filled = False
        self.set_c_2_impl = "static_cast<{implementation_type}>({expression})"
        self.set_c_2_impl_filled = False
        self.set_c_2_impl_mode = TC2ImplMode.default
        self.set_c_2_impl_mode_filled = False
        self.get_impl_2_c = "new {implementation_type}({expression})"
        self.get_impl_2_c_filled = False
        self.set_argument_type = ""
        self.set_argument_type_filled = False
        self.return_type = ""
        self.return_type_filled = False
        self.return_copy_or_add_ref = False
        self.return_copy_or_add_ref_filled = False
        self.documentations = []

    def load_element(self, element):
        if element.nodeName == "documentation":
            new_element = TDocumentation()
            new_element.load(element)
            self.documentations.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("type"):
            cur_attr = dom_node.getAttribute("type")
            self.type_name = cur_attr
            self.type_name_filled = True
        if dom_node.hasAttribute("set_prefix"):
            cur_attr = dom_node.getAttribute("set_prefix")
            self.set_prefix = cur_attr
            self.set_prefix_filled = True
        if dom_node.hasAttribute("get_prefix"):
            cur_attr = dom_node.getAttribute("get_prefix")
            self.get_prefix = cur_attr
            self.get_prefix_filled = True
        if dom_node.hasAttribute("get_const"):
            cur_attr = dom_node.getAttribute("get_const")
            self.get_const = string_to_bool(cur_attr)
            self.get_const_filled = True
        if dom_node.hasAttribute("set_argument_name"):
            cur_attr = dom_node.getAttribute("set_argument_name")
            self.set_argument_name = cur_attr
            self.set_argument_name_filled = True
        if dom_node.hasAttribute("is_builtin"):
            cur_attr = dom_node.getAttribute("is_builtin")
            self.is_builtin = string_to_bool(cur_attr)
            self.is_builtin_filled = True
        if dom_node.hasAttribute("set_c_2_impl"):
            cur_attr = dom_node.getAttribute("set_c_2_impl")
            self.set_c_2_impl = cur_attr
            self.set_c_2_impl_filled = True
        if dom_node.hasAttribute("set_c_2_impl_mode"):
            cur_attr = dom_node.getAttribute("set_c_2_impl_mode")
            self.set_c_2_impl_mode = TC2ImplMode.load(cur_attr)
            self.set_c_2_impl_mode_filled = True
        if dom_node.hasAttribute("get_impl_2_c"):
            cur_attr = dom_node.getAttribute("get_impl_2_c")
            self.get_impl_2_c = cur_attr
            self.get_impl_2_c_filled = True
        if dom_node.hasAttribute("set_argument_type"):
            cur_attr = dom_node.getAttribute("set_argument_type")
            self.set_argument_type = cur_attr
            self.set_argument_type_filled = True
        if dom_node.hasAttribute("return_type"):
            cur_attr = dom_node.getAttribute("return_type")
            self.return_type = cur_attr
            self.return_type_filled = True
        if dom_node.hasAttribute("return_copy_or_add_ref"):
            cur_attr = dom_node.getAttribute("return_copy_or_add_ref")
            self.return_copy_or_add_ref = string_to_bool(cur_attr)
            self.return_copy_or_add_ref_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TPropertySetPrefix(object):
    def __init__(self):
        self.all_items = []
        self.value = "Set"
        self.value_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("value"):
            cur_attr = dom_node.getAttribute("value")
            self.value = cur_attr
            self.value_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TPropertyGetPrefix(object):
    def __init__(self):
        self.all_items = []
        self.value = "Get"
        self.value_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("value"):
            cur_attr = dom_node.getAttribute("value")
            self.value = cur_attr
            self.value_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TPropertyGetConst(object):
    def __init__(self):
        self.all_items = []
        self.value = True
        self.value_filled = False

    def load_element(self, element):
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("value"):
            cur_attr = dom_node.getAttribute("value")
            self.value = string_to_bool(cur_attr)
            self.value_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


class TMappedType(object):
    def __init__(self):
        self.all_items = []
        self.name = ""
        self.name_filled = False
        self.wrap_type = ""
        self.wrap_type_filled = False
        self.argument_wrap_type = ""
        self.argument_wrap_type_filled = False
        self.c_type = ""
        self.c_type_filled = False
        self.implementation_type = ""
        self.implementation_type_filled = False
        self.snippet_type = ""
        self.snippet_type_filled = False
        self.wrap_2_c = "static_cast<{c_type}>({expression})"
        self.wrap_2_c_filled = False
        self.c_2_impl = "static_cast<{implementation_type}>({expression})"
        self.c_2_impl_filled = False
        self.impl_2_c = "static_cast<{c_type}>({expression})"
        self.impl_2_c_filled = False
        self.c_2_wrap = "static_cast<{wrap_type}>({expression})"
        self.c_2_wrap_filled = False
        self.include_headers = []

    def load_element(self, element):
        if element.nodeName == "include_header":
            new_element = THeaderInclude()
            new_element.load(element)
            self.include_headers.append(new_element)
            return True
        return False

    def load_attributes(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("wrap_type"):
            cur_attr = dom_node.getAttribute("wrap_type")
            self.wrap_type = cur_attr
            self.wrap_type_filled = True
        if dom_node.hasAttribute("argument_wrap_type"):
            cur_attr = dom_node.getAttribute("argument_wrap_type")
            self.argument_wrap_type = cur_attr
            self.argument_wrap_type_filled = True
        if dom_node.hasAttribute("c_type"):
            cur_attr = dom_node.getAttribute("c_type")
            self.c_type = cur_attr
            self.c_type_filled = True
        if dom_node.hasAttribute("implementation_type"):
            cur_attr = dom_node.getAttribute("implementation_type")
            self.implementation_type = cur_attr
            self.implementation_type_filled = True
        if dom_node.hasAttribute("snippet_type"):
            cur_attr = dom_node.getAttribute("snippet_type")
            self.snippet_type = cur_attr
            self.snippet_type_filled = True
        if dom_node.hasAttribute("wrap_2_c"):
            cur_attr = dom_node.getAttribute("wrap_2_c")
            self.wrap_2_c = cur_attr
            self.wrap_2_c_filled = True
        if dom_node.hasAttribute("c_2_impl"):
            cur_attr = dom_node.getAttribute("c_2_impl")
            self.c_2_impl = cur_attr
            self.c_2_impl_filled = True
        if dom_node.hasAttribute("impl_2_c"):
            cur_attr = dom_node.getAttribute("impl_2_c")
            self.impl_2_c = cur_attr
            self.impl_2_c_filled = True
        if dom_node.hasAttribute("c_2_wrap"):
            cur_attr = dom_node.getAttribute("c_2_wrap")
            self.c_2_wrap = cur_attr
            self.c_2_wrap_filled = True

    def load(self, dom_node):
        for element in dom_node.childNodes:
            self.load_element(element)
        self.load_attributes(dom_node)


def load(dom_node):
    for root_element in [root for root in dom_node.childNodes if root.localName == "api"]:
        root_params = TBeautifulCapiRoot()
        root_params.load(root_element)
        return root_params
